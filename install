#!/usr/bin/env bash
# Installation script for Chunkify CLI

set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
ORANGE='\033[38;2;255;140;0m'
NC='\033[0m'

# App specifics
APP="chunkify"
INSTALL_DIR=$HOME/.chunkify/bin
mkdir -p "$INSTALL_DIR"

REPO_OWNER="chunkifydev"
REPO_NAME="cli"

requested_version=${VERSION:-}

# OS/Arch detection and normalization
os=$(uname -s | tr '[:upper:]' '[:lower:]')
if [[ "$os" == "darwin" ]]; then
    os="darwin"
elif [[ "$os" == "linux" ]]; then
    os="linux"
else
    echo -e "${RED}Unsupported OS: $os${NC}"
    exit 1
fi

arch=$(uname -m | tr '[:upper:]' '[:lower:]')
if [[ "$arch" == "aarch64" ]]; then
    arch="arm64"
fi

# Filename pattern MUST stay consistent with existing releases
# Keep: chunkify_${os}_${arch}.tar.gz
filename="${APP}_${os}_${arch}.tar.gz"

# Validate supported combos (conservative)
case "$filename" in
    *"-windows-"*)
        echo -e "${RED}Windows is not supported by this installer${NC}"
        exit 1
    ;;
    *)
        :
    ;;
esac

# Resolve version and construct download URL (preserve existing URL scheme)
if [[ -z "$requested_version" ]]; then
    # Get latest tag (e.g. v1.2.3)
    tag=$(curl -s https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/releases/latest | sed -n 's/.*"tag_name": *"\([^"]*\)".*/\1/p')
    if [[ -z "${tag}" ]]; then
        echo -e "${RED}Failed to fetch latest release tag${NC}"
        exit 1
    fi
    specific_version="$tag"
else
    # Allow both with or without leading v
    if [[ "$requested_version" == v* ]]; then
        specific_version="$requested_version"
    else
        specific_version="v${requested_version}"
    fi
fi

echo -e "
  ██   ▗▄▄▖▗▖ ▗▖▗▖ ▗▖▗▖  ▗▖▗▖ ▗▖▗▄▄▄▖▗▄▄▄▖▗▖  ▗▖
██    ▐▌   ▐▌▄▐▌▐▌ ▐▌▐▛▚▖▐▌▐▌▗▞▘  █  ▐▌▗▖  ▝▚▞▘ 
  ██  ▝▚▄▄▖▐▌ ▐▌▝▚▄▞▘▐▌  ▐▌▐▌ ▐▌▗▄█▄▖▐▌     ▐▌                                           

Chunkify CLI version: ${specific_version}
https://chunkify.dev
────────────────────────────────────────────────
"

# Keep the original URL construction style
download_url="https://github.com/${REPO_OWNER}/${REPO_NAME}/releases/download/${specific_version}/${APP}_${os}_${arch}.tar.gz"

print_message() {
    local level=$1
    local message=$2
    local color=""
    case $level in
        info) color="${GREEN}" ;;
        warning) color="${YELLOW}" ;;
        error) color="${RED}" ;;
    esac
    echo -e "${color}${message}${NC}"
}

check_version() {
    if command -v "$APP" >/dev/null 2>&1; then
        # Try to read installed version; tolerate failures
        if installed_output=$($APP version 2>/dev/null || true); then
            # Expect something like: chunkify version x.y.z or similar; extract semver
            installed_version=$(echo "$installed_output" | grep -Eo '[0-9]+\.[0-9]+\.[0-9]+' | head -n1 || true)
        else
            installed_version=""
        fi

        target_version_clean=$(echo "$specific_version" | sed 's/^v//')
        if [[ -n "$installed_version" && "$installed_version" == "$target_version_clean" ]]; then
            print_message info "Version ${YELLOW}$specific_version${GREEN} already installed"
            exit 0
        elif [[ -n "$installed_version" ]]; then
            print_message info "Installed version: ${YELLOW}$installed_version${GREEN}. Updating to ${YELLOW}$target_version_clean${GREEN}."
        fi
    fi
}

download_and_install() {
    print_message info "Downloading ${ORANGE}${APP} ${GREEN}version: ${YELLOW}$specific_version ${GREEN}..."
    workdir=$(mktemp -d)
    trap 'rm -rf "$workdir"' EXIT
    curl -# -L -o "$workdir/$filename" "$download_url"
    tar -C "$workdir" -xzf "$workdir/$filename"
    chmod +x "$workdir/$APP"
    mv "$workdir/$APP" "$INSTALL_DIR"
}

add_to_path() {
    local config_file=$1
    local command=$2
    if grep -Fxq "$command" "$config_file" 2>/dev/null; then
        print_message info "Command already exists in $config_file, skipping write."
    elif [[ -w $config_file ]]; then
        echo -e "\n# chunkify" >> "$config_file"
        echo "$command" >> "$config_file"
    else
        print_message warning "Manually add the directory to $config_file (or similar):"
        print_message info "  $command"
    fi
}

check_version
download_and_install

# PATH integration
current_shell=$(basename "${SHELL:-}")
XDG_CONFIG_HOME=${XDG_CONFIG_HOME:-$HOME/.config}
case $current_shell in
    fish)
        config_files="$HOME/.config/fish/config.fish"
    ;;
    zsh)
        config_files="$HOME/.zshrc $HOME/.zshenv $XDG_CONFIG_HOME/zsh/.zshrc $XDG_CONFIG_HOME/zsh/.zshenv"
    ;;
    bash)
        config_files="$HOME/.bashrc $HOME/.bash_profile $HOME/.profile $XDG_CONFIG_HOME/bash/.bashrc $XDG_CONFIG_HOME/bash/.bash_profile"
    ;;
    ash|sh)
        config_files="$HOME/.ashrc $HOME/.profile /etc/profile"
    ;;
    *)
        config_files="$HOME/.bashrc $HOME/.bash_profile $XDG_CONFIG_HOME/bash/.bashrc $XDG_CONFIG_HOME/bash/.bash_profile"
    ;;
esac

config_file=""
for file in $config_files; do
    if [[ -f $file ]]; then
        config_file=$file
        break
    fi
done

if [[ ":$PATH:" != *":$INSTALL_DIR:"* ]]; then
    case $current_shell in
        fish)
            add_to_path "$config_file" "fish_add_path $INSTALL_DIR"
        ;;
        zsh)
            add_to_path "$config_file" "export PATH=$INSTALL_DIR:\$PATH"
        ;;
        bash)
            add_to_path "$config_file" "export PATH=$INSTALL_DIR:\$PATH"
        ;;
        ash)
            add_to_path "$config_file" "export PATH=$INSTALL_DIR:\$PATH"
        ;;
        sh)
            add_to_path "$config_file" "export PATH=$INSTALL_DIR:\$PATH"
        ;;
        *)
            export PATH=$INSTALL_DIR:$PATH
            print_message warning "Manually add the directory to $config_file (or similar):"
            print_message info "  export PATH=$INSTALL_DIR:\$PATH"
        ;;
    esac
fi


echo -e "${GREEN}Chunkify CLI was installed successfully to $INSTALL_DIR${NC}"
echo "Run 'chunkify config token <sk_project_token>' to get started"
